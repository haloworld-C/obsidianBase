C++多线程程序在linux平台上编译需要添[-pthread] flag. 
### core concept
- 数据竞争
#### 原子操作std::atomic
对于基本内置数据可以使用std::atomic来保证多线程环境中一个线程读取，另一个线程中写入的数据安全性, 基本用法如下
```C++
#include <iostream>
#include <thread>
#include <atomic>

std::atomic<int> global_var(0);

void writer() {
    for (int i = 0; i < 100; ++i) {
        global_var.store(i);
    }
}

void reader() {
    for (int i = 0; i < 100; ++i) {
        int val = global_var.load();
        std::cout << val << std::endl;
    }
}

int main() {
    std::thread t1(writer);
    std::thread t2(reader);

    t1.join();
    t2.join();

    return 0;
}

```
#### 互斥锁
- std::mutex
基本用法如下:
```C++
#include <iostream>
#include <thread>
#include <mutex>

int global_var = 0; // 全局变量
std::mutex mtx; // 用于保护global_var的互斥锁

void writer() {
    for (int i = 0; i < 100; ++i) {
        std::lock_guard<std::mutex> lock(mtx);
        global_var += 1;
    }
}

void reader() {
    int local_copy;
    for (int i = 0; i < 100; ++i) {
        std::lock_guard<std::mutex> lock(mtx);
        local_copy = global_var;
        std::cout << local_copy << std::endl;
    }
}

int main() {
    std::thread t1(writer);
    std::thread t2(reader);

    t1.join();
    t2.join();

    return 0;
}

```